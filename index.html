
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ironmantony</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="ironmantony">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ironmantony">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ironmantony">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="ironmantony" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ironmantony</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">不要想着远处的路有多远，要知道你是在走一小步，你能办到的！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-Fragment的创建和管理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/19/Fragment的创建和管理/" class="article-date">
  <time datetime="2016-10-19T10:59:06.000Z" itemprop="datePublished">2016-10-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/19/Fragment的创建和管理/">Fragment的创建和管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>我们很多应用都涉及到fragment的创建和管理，比如：下面n个tab，上面n个fragment的组合，activity管理多个fragment或者一个fragment等等。</p>
</blockquote>
<p>很多应用在MainActivity里的onCreate里去 一 一 实例化fragment，然后在tab切换的时候使用FragmentTransaction去添加或者替换fragment。<br>大概是这么写的<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate<span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    super.onCreate<span class="params">(savedInstanceState)</span>;</span><br><span class="line">    Log.e<span class="params">(<span class="string">"StateActivity"</span>, <span class="string">"---------------onCreate"</span>)</span>;</span><br><span class="line">    setContentView<span class="params">(R.layout.activity_main_for_state)</span>;</span><br><span class="line">    FragmentManager fm = getSupportFragmentManager<span class="params">()</span>;</span><br><span class="line">    FragmentTransaction ft = fm.beginTransaction<span class="params">()</span>;</span><br><span class="line">    ft.replace<span class="params">(R.id.state_fragment_container, Fragment1.newInstance<span class="params">(<span class="string">""</span>, <span class="string">""</span>)</span>)</span>;</span><br><span class="line">    ft.commit<span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种有没有问题呢？看着好像没有问题，但是如果你打开不保存状态然后再调试或者打印log你就会会发现问题了。</p>
<p>我们有A，B两个Activity，A里有一个fragment，fragment里有一个按钮，可以跳转到Activity B。</p>
<p>我们打开不保存状态，点击fragment里的按钮跳转到B，然后返回，看看A以及fragment的哪些生命周期调用了<br>看看log的打印信息：<br><img src="/imgs/log1.png" alt=""><br>（test是在onSavedInstanceState中保存的字符串）</p>
<p>我们可以看到：</p>
<pre><code><span class="bullet">1. </span>Fragment被创建两次。
<span class="bullet">2. </span>第二次创建的fragment获取不到我们保存的状态。
</code></pre><p>想一想也是有道理的：<br>在不保存状态的情况下，跳转到B之后，A和A里面的fragment都被销毁了，回到A的时候，log中打印的第一个fragment是系统保存状态然后恢复的fragment，所以保存的状态都能获取到，但是第二个fragment是在恢复activity运行生命周期onCreate方法的时候我们代码new出来的，所以第二个fragment里面是没有我们之前保存的状态的。</p>
<p>这种问题要怎么解决呢？<br>如果只是解决问题1，重复创建fragment的情况（不想有两个fragment实例，因为有的如果是透明fragment可能还会出现重叠），很好解决使用replace，或者不调用fragment的super.onSavedInsance()等等。</p>
<h3 id="但是如果我们想要在fragment中保存状态要怎么办呢？">但是如果我们想要在fragment中保存状态要怎么办呢？</h3><h3 id="1如果是一个fragment的activity。">1如果是一个fragment的activity。</h3><p>我们可以先从fragmentManager里去取，如果取到了，那么说明这个fragment已经有了，那么我们就什么也不做，如果没取到，我们再去创建。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate<span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    super.onCreate<span class="params">(savedInstanceState)</span>;</span><br><span class="line">    Log.e<span class="params">(<span class="string">"StateActivity"</span>, <span class="string">"---------------onCreate"</span>)</span>;</span><br><span class="line">    setContentView<span class="params">(R.layout.activity_main_for_state)</span>;</span><br><span class="line">    FragmentManager fm = getSupportFragmentManager<span class="params">()</span>;</span><br><span class="line">    Fragment1 f = <span class="params">(Fragment1)</span> fm.findFragmentByTag<span class="params">(TAG_FRAGMENT1)</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(f == null)</span> &#123;</span><br><span class="line">        FragmentTransaction ft = fm.beginTransaction<span class="params">()</span>;</span><br><span class="line">        f = Fragment1.newInstance<span class="params">(<span class="string">""</span>, <span class="string">""</span>)</span>;</span><br><span class="line">        ft.add<span class="params">(R.id.state_fragment_container, f, TAG_FRAGMENT1)</span>;</span><br><span class="line">        ft.commit<span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来运行一下看看log：<br><img src="/imgs/log2.png" alt=""></p>
<p>Fragment只被创建了一次，并且也能获取到他所保存的状态。<br>（其实也可以根据savedInstanceState是否为空来判断是否需要重新创建fragment。）</p>
<h3 id="如果一个activity里需要创建多个fragment并且以tab的方式来切换，我们应该怎么做？">如果一个activity里需要创建多个fragment并且以tab的方式来切换，我们应该怎么做？</h3><p>借鉴fragmentTabHost里的做法，用一个TabInfo实体类来保存对应的tab和fragment之间的关系。对于fragment的创建，还是先从fragmentManager里去取，如果没有再去创建。</p>
<p>使用一个TabInfo实体类来保存fragment和每个tab之间的关系。<br>比如：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TabInfo &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String tag;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Fragment&gt; clazz;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> viewId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TabInfo(String tag, <span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Fragment&gt; clazz, <span class="keyword">int</span> viewId) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tag = tag;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        <span class="keyword">this</span>.viewId = viewId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后用一个list来保存所有的tab信息：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;TabInfo&gt; tabInfos = <span class="keyword">new</span> ArrayList&lt;TabInfo&gt;(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//在onCreate()中初始化tab</span></span><br><span class="line">tabInfos.<span class="keyword">add</span>(<span class="keyword">new</span> TabInfo(Fragment1.<span class="keyword">class</span>.getSimpleName(), Fragment1.<span class="keyword">class</span>, R.id.tab_right));</span><br><span class="line">tabInfos.<span class="keyword">add</span>(<span class="keyword">new</span> TabInfo(Fragment2.<span class="keyword">class</span>.getSimpleName(), Fragment2.<span class="keyword">class</span>, R.id.tab_left));</span><br></pre></td></tr></table></figure></p>
<p>当然这里做的比较粗糙，使用两个按钮做tab，也可以使用其他的自定义view。</p>
<p>切换的时候<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void switchTab<span class="params">(int tabIndex)</span> &#123;</span><br><span class="line">    TabInfo tabInfo = tabInfos.get<span class="params">(tabIndex)</span>;</span><br><span class="line">    FragmentManager fm = getSupportFragmentManager<span class="params">()</span>;</span><br><span class="line">    Fragment f = fm.findFragmentByTag<span class="params">(tabInfo.tag)</span>;</span><br><span class="line">    FragmentTransaction transaction = fm.beginTransaction<span class="params">()</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(f == null)</span> &#123;</span><br><span class="line">        f = Fragment.instantiate<span class="params">(this, tabInfo.clazz.getName<span class="params">()</span>)</span>;</span><br><span class="line">        transaction.add<span class="params">(R.id.tab_fragment_container, f, tabInfo.tag)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(currentFragment != null &amp;&amp; currentFragment != f)</span> &#123;</span><br><span class="line">        transaction.hide<span class="params">(currentFragment)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    transaction.show<span class="params">(f)</span>;</span><br><span class="line">    transaction.commit<span class="params">()</span>;</span><br><span class="line">    currentFragment = f;</span><br><span class="line">    this.tabIndex = tabIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里替换fragment用的是show/hide（不销毁fragment和视图），当然你也可以使用detach/attach（只销毁视图不销毁fragment实例）<br><a href="http://www.voidcn.com/blog/u013168615/article/p-5794851.html" target="_blank" rel="external">http://www.voidcn.com/blog/u013168615/article/p-5794851.html</a> （这篇文章讲show/hide，detach/attach等等比较详细）</p>
<p>再来看看我们的log：<br><img src="/imgs/log3.png" alt=""><br>一切正常！</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/10/19/Fragment的创建和管理/" data-id="ciuh05bn0000cu8xpxlw5x9em" class="article-share-link">分享到</a>
      

      

      
    </footer>
  </div>
  
</article>


  
    <article id="post-java线程池和对象池" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/03/java线程池和对象池/" class="article-date">
  <time datetime="2015-10-03T11:11:21.000Z" itemprop="datePublished">2015-10-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/03/java线程池和对象池/">java线程池和对象池</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="java线程池">java线程池</h1><p>原文链接：（讲的比较详细）<br><a href="http://www.infoq.com/cn/articles/java-threadPool#anch97718" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-threadPool#anch97718</a></p>
<h2 id="线程池的创建">线程池的创建</h2><p>我们可以通过ThreadPoolExecutor来创建一个线程池。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, <span class="keyword">handler</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="创建一个线程池需要输入几个参数：">创建一个线程池需要输入几个参数：</h3><ol>
<li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</li>
<li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。</p>
<ul>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
</li>
<li><p>maximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</p>
</li>
<li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li>
<li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。</p>
<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li>
</ul>
</li>
<li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</p>
</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li>
</ol>
<h3 id="向线程池提交任务">向线程池提交任务</h3><ul>
<li><p>我们可以使用execute提交的任务，但是execute方法没有返回值，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute方法输入的任务是一个Runnable类的实例。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(new <span class="type">Runnable</span>() &#123;</span><br><span class="line">            @<span class="type">Override</span></span><br><span class="line">            public <span class="type">void</span> run() &#123;</span><br><span class="line">                // <span class="type">TODO</span> <span class="type">Auto</span>-generated <span class="keyword">method</span> stub</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们也可以使用submit 方法来提交任务，它会返回一个future,那么我们可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成，而使用<code>get(long timeout, TimeUnit unit)</code>方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="built_in">Object</span>&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="built_in">Object</span> s = future.<span class="literal">get</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="线程池的关闭">线程池的关闭</h2><p>我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，<code>shutdownNow</code>首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。<br>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。</p>
<h2 id="线程池的分析">线程池的分析</h2><ul>
<li>流程分析：线程池的主要工作流程如下图：<br><img src="/imgs/threadpool.jpg" alt=""></li>
</ul>
<p>从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</p>
<ol>
<li>首先线程池判断基本线程池是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。</li>
<li>其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</li>
<li>最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</li>
</ol>
<ul>
<li>源码分析。上面的流程分析让我们很直观的了解了线程池的工作原理，让我们再通过源代码来看看是如何实现的。线程池执行任务的方法如下：<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void execute<span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(command == null)</span></span><br><span class="line">       throw new NullPointerException<span class="params">()</span>;</span><br><span class="line">    <span class="comment">//如果线程数小于基本线程数，则创建线程并执行当前任务 </span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize<span class="params">(command)</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">        <span class="keyword">if</span> <span class="params">(runState == RUNNING &amp;&amp; workQueue.offer<span class="params">(command)</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(runState != RUNNING || poolSize == <span class="number">0</span>)</span></span><br><span class="line">                      ensureQueuedTaskHandled<span class="params">(command)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，</span></span><br><span class="line">则创建一个线程执行任务。</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(!addIfUnderMaximumPoolSize<span class="params">(command)</span>)</span></span><br><span class="line">        <span class="comment">//抛出RejectedExecutionException异常</span></span><br><span class="line">            reject<span class="params">(command)</span>; <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>工作线程。线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。我们可以从Worker的run方法里看到这点：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">           Runnable <span class="keyword">task</span> = firstTask;</span><br><span class="line">           firstTask = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">task</span> != <span class="keyword">null</span> || (<span class="keyword">task</span> = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    runTask(<span class="keyword">task</span>);</span><br><span class="line">                    <span class="keyword">task</span> = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             workerDone(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="如何复用线程：">如何复用线程：</h3><p>从上面也可以看出来：<br>是通过无限循环获取工作队列里的任务来执行，并且在自己的run方法中直接调用Runnable.run()方法，这样并没有开启新的线程，而是处理了我们提交的线程里需要执行的任务，这样就达到了复用线程的目的了。</p>
<hr>
<h1 id="对象池：">对象池：</h1><h2 id="参考资料：">参考资料：</h2><p><a href="http://www.cnblogs.com/rubylouvre/p/3314775.html" target="_blank" rel="external">http://www.cnblogs.com/rubylouvre/p/3314775.html</a></p>
<h2 id="对象池的作用：">对象池的作用：</h2><p>限制一个类的对象的个数，（单例是限制了一个类只能有一个实例，对象池则是限制一个类实例的个数）</p>
<h2 id="实现方式：">实现方式：</h2><p>也是跟线程池差不多，在创建新对象的时候去判断是重新创建还是去池里取还是等待，从而达到复用对象的功能。这里重新创建和等待都很好理解，那么如何判断一个已经创建的对象是否可用呢？这就需要使用方在用完这个对象的时候去将这个对象设置为空闲，也就是相当于手动释放。理解了这个，对象池还是很好理解的。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/10/03/java线程池和对象池/" data-id="ciuh05bo0000zu8xppos3pvna" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android插件化开发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/29/android插件化开发/" class="article-date">
  <time datetime="2015-09-29T14:54:52.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/29/android插件化开发/">android插件化开发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>昨天一不小心搞出一个bug，而且还是崩溃，但是很快我就找到了原因，并且修复了bug提交了代码，一会儿qa马上热发了一版，这样我的崩溃问题就解决了，这也太快了！Android更新不是要先发应用市场，然后等待好几周的审核，然后有的用户还不肯更新吗？这里面到底用到了什么黑科技？于是我想知道android热发的原理，开始查android热发，没有找到什么有价值的东西，后来搜android 组件化开发，在知乎上找到一篇，回答很简单，但是有一个链接到他详细博客的地址<a href="http://www.trinea.cn/android/android-plugin/" target="_blank" rel="external">http://www.trinea.cn/android/android-plugin/</a> ，根据博客里面提供的信息，我了解了几个开源框架是如何实现热加载，或者说是热发的。</p>
<hr>
<h2 id="热发的过程：">热发的过程：</h2><ol>
<li>apk插件更新：通过差分（bsdiff），来更新需要更新的apk插件，最小化用户的下载量。</li>
<li>宿主程序动态加载更新之后的apk插件，完成热发。</li>
</ol>
<hr>
<h2 id="组件开发的概念：">组件开发的概念：</h2><blockquote>
<p>宿主程序通过ClassLoader去动态加载apk文件并将其放在自己的进程中执行。</p>
</blockquote>
<hr>
<h2 id="基本概念理解资料：">基本概念理解资料：</h2><ul>
<li>ClassLoader：<br><a href="http://www.trinea.cn/android/java-loader-common-class/" target="_blank" rel="external">http://www.trinea.cn/android/java-loader-common-class/</a><br><a href="http://android-developers.blogspot.hk/2011/07/custom-class-loading-in-dalvik.html" target="_blank" rel="external">http://android-developers.blogspot.hk/2011/07/custom-class-loading-in-dalvik.html</a>  （进阶）    </li>
<li>AndroidApk动态加载机制<br><a href="http://blog.csdn.net/singwhatiwanna/article/details/22597587" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/22597587</a><br><a href="http://blog.csdn.net/singwhatiwanna/article/details/23387079" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/23387079</a></li>
<li>开源项目dl的介绍：<br><a href="http://blog.csdn.net/singwhatiwanna/article/details/39937639" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/39937639</a></li>
</ul>
<hr>
<h2 id="组件开发的好处：">组件开发的好处：</h2><ul>
<li>动态更新。不用频繁卸载安装apk程序。</li>
<li>可以多个项目同时开发，减少apk的大小，并且每个项目可以同时进行，减少编译时间等等。</li>
</ul>
<hr>
<h2 id="组件开发需要解决的问题：">组件开发需要解决的问题：</h2><p><a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">https://github.com/singwhatiwanna/dynamic-load-apk</a> 这个很好地解释了为什么会有这两个问题</p>
<ol>
<li><p>Activity生命周期的管理。</p>
<blockquote>
<p>apk被宿主程序调起以后，apk中的activity其实就是一个普通的对象，不具有activity的性质 ，因为系统启动activity是要做很多初始化工作的，而我们在应用层通过反射去启动activity是很难完成系统所做的初始化工作的，所以activity的大部分特性都无法使用包括activity的生命周期管理，这就需要我们自己去管理。</p>
</blockquote>
</li>
<li><p>资源的访问。</p>
<blockquote>
<p>我们知道，宿主程序调起未安装的apk，一个很大的问题就是资源如何访问，具体来说就是，凡是以R开头的资源都不能访问了，因为宿主程序中并没有apk中的资源，所以通过R来加载资源是行不通的，程序会报错：无法找到某某id所对应的资源。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="几种动态加载开源项目的实现：">几种动态加载开源项目的实现：</h2><p>原文链接：<a href="http://www.trinea.cn/android/android-plugin/" target="_blank" rel="external">http://www.trinea.cn/android/android-plugin/</a>    </p>
<ol>
<li><p>DynamicLoadApk<br>GitHub：<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">https://github.com/singwhatiwanna/dynamic-load-apk</a><br>这个项目实现了一部分的动态加载，原理是 DexClassLoader 加 Activity 代理，可以看看。即在容器中注册几个代理的 Activity，启动插件的 Activity 时实际启动的都是代理的 Activity，这样就解决了 Activity 必须注册的问题。<br>当然这个项目里也有不少问题没解决，有兴趣可以加入他们。  </p>
</li>
<li><p>AndroidDynamicLoader GitHub：<a href="https://github.com/mmin18/AndroidDynamicLoader" target="_blank" rel="external">https://github.com/mmin18/AndroidDynamicLoader</a><br>这是点评一个工程师介绍的方式，和上面不同的是：他不是用代理 Activity 的方式实现而是用 Fragment 以及 schema 的方式实现  </p>
</li>
<li><p>Android PluginManager GitHub：<a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">https://github.com/houkx/android-pluginmgr</a><br>这个项目的原理实际也是 DexClassLoader 加 Activity 代理，不同的是上面的 dynamic-load-apk 项目中，插件需要依赖框架的 lib，插件组件继承框架 lib 的 Base 组件。而这个框架通过字节码操作动态生成一个子类去继承插件组件解决插件必须依赖框架的问题，从而达到插件无需做任何改动(理论上)即可加载的效果。</p>
</li>
</ol>
<p>最近的：</p>
<ul>
<li><p>淘宝的 Atlas现在更名为ACDD<br><a href="https://github.com/bunnyblue/ACDD" target="_blank" rel="external">https://github.com/bunnyblue/ACDD</a><br><a href="https://github.com/bunnyblue/ACDDExtension" target="_blank" rel="external">https://github.com/bunnyblue/ACDDExtension</a></p>
</li>
<li><p>360 的 DroidPlugin<br><a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="external">https://github.com/Qihoo360/DroidPlugin</a></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/09/29/android插件化开发/" data-id="ciuh05boa0019u8xpvpl4oizg" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RadioGroup-check-的坑" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/29/RadioGroup-check-的坑/" class="article-date">
  <time datetime="2015-09-29T03:40:43.000Z" itemprop="datePublished">2015-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/29/RadioGroup-check-的坑/">RadioGroup.check()的坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="问题描述：">问题描述：</h3><p>我使用RadioGroup.check()方法来初始化radioGroup，然后我在onCheckedChanged()里去根据选择的radioButton来发送网络请求，并且新建fragment。这时候我发现一个问题：这个radiobutton下的网络请求会发送两次，而且fragment也会创建两次，而且那个新建的fragment里还有很多的初始化过程和网络请求，所以会让用户一直处在等待的状态。</p>
<p>开始时候各种找原因，以为是我在哪里调用了太多次，还是共用layout文件有相同的id所以被别的地方的调用影响了？都不是，最后在stackoverflow上找到了答案：使用RadioGroup.check()会调用onCheckedChanged()方法三次，而我在onCheckedChanged()方法里判断了调用的是哪个id，然后发送请求创建fragmeng，所以只调用了两次。</p>
<h3 id="statckoverflow原文链接：">statckoverflow原文链接：</h3><p><a href="http://stackoverflow.com/questions/10263778/radiogroup-calls-oncheckchanged-three-times" target="_blank" rel="external">http://stackoverflow.com/questions/10263778/radiogroup-calls-oncheckchanged-three-times</a></p>
<p><img src="/imgs/radiogroupChecks.png" alt=""></p>
<h3 id="RadioGroup-check()源码如下：">RadioGroup.check()源码如下：</h3><p><a href="http://www.grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.1.1_r1/android/widget/RadioGroup.java#RadioGroup.check%28int%29" target="_blank" rel="external">http://www.grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.1.1_r1/android/widget/RadioGroup.java#RadioGroup.check%28int%29</a></p>
<p><img src="/imgs/radiogroup2.png" alt=""></p>
<h3 id="解决方法_：">解决方法 ：</h3><p>使用radioBotton.setChecked()方法来解决</p>
<p><img src="/imgs/radiogroup3.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/09/29/RadioGroup-check-的坑/" data-id="ciuh05blr0000u8xprx63vc4l" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-io" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/18/java-io/" class="article-date">
  <time datetime="2015-08-18T08:36:20.000Z" itemprop="datePublished">2015-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/18/java-io/">java io</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="java_io继承关系图：">java io继承关系图：</h2><p><img src="/imgs/java-io.png" alt=""></p>
<h2 id="inputStream_vs_Reader">inputStream vs Reader</h2><p><a href="http://stackoverflow.com/questions/4367539/what-is-the-difference-between-reader-and-inputstream" target="_blank" rel="external">http://stackoverflow.com/questions/4367539/what-is-the-difference-between-reader-and-inputstream</a><br>An InputStream is the raw method of getting information from a resource. It grabs the data byte by byte without performing any kind of translation. If you are reading image data, or any binary file, this is the stream to use.<br>A Reader is designed for character streams. If the information you are reading is all text, then the Reader will take care of the character decoding for you and give you unicode characters from the raw input stream. If you are reading any type of text, this is the stream to use.<br>You can wrap an InputStream and turn it into a Reader by using the InputStreamReader class.<br><code>Reader reader = new InputStreamReader(inputStream);</code></p>
<h2 id="solution:">solution:</h2><p>如果是读取字符类文件，可以使用Reader和Writer，不用担心编码问题。<br>如果是读取二进制文件，图片等等可以使用InputStream和OutputStream。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/08/18/java-io/" data-id="ciuh05bo30012u8xptz7hzucd" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-some-useful-git-command" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/18/some-useful-git-command/" class="article-date">
  <time datetime="2015-08-18T08:35:10.000Z" itemprop="datePublished">2015-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/18/some-useful-git-command/">some useful git command</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="不提交一个文件（已经在仓库中，并且不想将远程仓库中的文件删除）在本地的改变">不提交一个文件（已经在仓库中，并且不想将远程仓库中的文件删除）在本地的改变</h2><h3 id="GIT:_ignoring_changes_in_tracked_files29/01/2009">GIT: ignoring changes in tracked files29/01/2009</h3><p>There may be times when you want to edit some variables in for example a database connection file, to run an application right from within your GIT repo. Of course you don’t wont those changes to be commited, so you add the file the .gitignore.<br>However adding tracked files to .gitignore won’t work because GIT will still track the changes and commit the file if you use the -a parameter.<br>Fortunately GIT has a very easy solution for this, just run the following command on the file or path you want to ignore the changes of:</p>
<blockquote>
<p><code>git update-index --assume-unchanged &lt;file&gt;</code>    </p>
</blockquote>
<p>If you wanna start tracking changes again run the following command:</p>
<blockquote>
<p><code>git update-index --no-assume-unchanged &lt;file&gt;</code></p>
</blockquote>
<h3 id="参考资料：">参考资料：</h3><p><a href="http://blog.pagebakers.nl/2009/01/29/git-ignoring-changes-in-tracked-files/" target="_blank" rel="external">http://blog.pagebakers.nl/2009/01/29/git-ignoring-changes-in-tracked-files/</a></p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/08/18/some-useful-git-command/" data-id="ciuh05bnx000xu8xpdr09i92n" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-AysncTask源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/06/AysncTask源码解析/" class="article-date">
  <time datetime="2015-08-06T08:03:13.000Z" itemprop="datePublished">2015-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/06/AysncTask源码解析/">AysncTask源码解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AsyncTask的类图">AsyncTask的类图</h2><p><img src="/imgs/asynctask.png" alt=""></p>
<ul>
<li>其中，如果使用默认的Executor其实AsyncTask中的任务是一个一个执行的。<br>其中灰色的是接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    Runnable mActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这段代码中可以看出来。<br>如果使用Thread_pool_executor那么就会使用线程池来执行你的task。<br>注释中也有：</p>
<p>Order of execution</p>
<p>When first introduced, AsyncTasks were executed serially on a single background<br>thread. Starting with {android.os.Build.VERSION_CODES#DONUT}, this was changed<br>to a pool of threads allowing multiple tasks to operate in parallel. Starting with<br>android.os.Build.VERSION_CODES#HONEYCOMB, tasks are executed on a single<br>thread to avoid common application errors caused by parallel execution</p>
<p> If you truly want parallel execution, you can invoke<br>executeOnExecutor(java.util.concurrent.Executor, Object[])} with<br>THREAD_POOL_EXECUTOR</p>
<ul>
<li><p>从类图可以看出来AsyncTask主要使用了组合的方式来使用代码。</p>
</li>
<li><p>理解代码的一个方式是画类图，然后找一个入口然后看下去，看他是如何调用的。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/08/06/AysncTask源码解析/" data-id="ciuh05bn3000du8xpj12w3h7w" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/sourcecode-analyze/">sourcecode analyze</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-idea上一些实用的快捷键" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/06/17/idea上一些实用的快捷键/" class="article-date">
  <time datetime="2015-06-17T08:37:43.000Z" itemprop="datePublished">2015-06-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/17/idea上一些实用的快捷键/">idea上一些实用的快捷键</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这里列出的是我自认为使用比较多比较实用的一些，并不全，如果想看全的，可以推荐这一篇：<br><a href="http://www.cnblogs.com/tonycody/p/3257601.html" target="_blank" rel="external">http://www.cnblogs.com/tonycody/p/3257601.html</a></p>
<ul>
<li><p>ctrl + P<br>列出参数列表（使用比较多 ）</p>
</li>
<li><p>ctrl + shift + enter<br>当在括号里输入完最后一个参数时候他会直接光标跳到最后并且添加分号，不需要自己按向左键移动光标。（使用比较多 ）<br>ctrl + enter 向下插入一行，光标位置不变</p>
</li>
<li><p>shift + enter<br>向下插入一行。光标位置进入下一行（可以在一行的任何位置换行，而不必将光标移动到行尾，使用比较多）</p>
</li>
<li><p>ctrl+left/right<br>在单词间跳动光标，基本在所有的编辑器中都是适用 （使用比较多 ）</p>
</li>
<li><p>ctr+shitf+left/right<br>快速选中，基本在所有的编辑器中都是适用（shift选中，ctrl+left/right在单词中快速跳动，使用比较多 ）</p>
</li>
<li><p>Alt+left/right，切换代码视图（使用比较多 ）</p>
</li>
<li><p>Alt+Up/Down，在方法间快速移动定位（使用比较多 ）</p>
</li>
<li><p>F2 或 Shift+F2，高亮错误或警告快速定位（使用比较多）</p>
</li>
<li><p>Ctrl+Alt+T<br>可以把代码包在一个块内，例如：try/catch（使用比较多 ）</p>
</li>
<li><p>Ctrl+F，处于查找状态下按down向下查找，up向上查找（使用比较多）</p>
</li>
<li><p>Ctrl+F12，可以显示当前文件的结构（快速查找当前类中某个方法，使用比较多）</p>
</li>
<li><p>Ctrl+Shift+W，取消选择光标所在词（使用比较多）</p>
</li>
<li>Ctrl+[ OR ]，可以跑到大括号的开头与结尾</li>
<li><p>Ctrl+Shift +[ OR ]，选择大括号中的内容</p>
</li>
<li><p>alt + 1 同上（在工程目录和编辑页面间切换，使用比较多）</p>
</li>
<li><p>Ctrl+Alt+O，优化导入的类和包(去掉没有使用的import，使用比较多 )</p>
</li>
<li><p>Shift+F6，重构 - 重命名（使用比较多 ）</p>
</li>
<li><p>Ctrl+G，定位行</p>
</li>
<li><p>Ctrl+H，显示类结构图（类的继承层次）</p>
</li>
<li><p>Ctrl+U，转到父类</p>
</li>
<li><p>Ctrl+”+/-“，当前方法展开、折叠</p>
</li>
<li><p>Ctrl+Shift+”+/-“，全部展开、折叠</p>
</li>
<li><p>Ctrl+Shift+J，整合两行</p>
</li>
<li><p>ctrl + shift + space<br>当new 一个变量的时候，已经写了变量类型，打了等号之后按这个可以快速完成。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/06/17/idea上一些实用的快捷键/" data-id="ciuh05bo50014u8xpaw183uwk" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tools/">tools</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-gralde 循环依赖的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/23/gralde 循环依赖的问题/" class="article-date">
  <time datetime="2015-05-23T02:42:24.000Z" itemprop="datePublished">2015-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/23/gralde 循环依赖的问题/">gralde 循环依赖的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天遇到一个问题，添加一个EventBus依赖包之后运行一直报：‘java.exe finished with non-zero exit value 2 ’</p>
<p>在statckoverflow上找到了问题的答案：</p>
<blockquote>
<p>First of all you should try to list your dependencies with gradle :MODULE:dependencies Check if there are libraries conflicts ( same library but different version ). In this case i supose you should exclude support library module from Facebook SDK.</p>
<pre><code><span class="keyword">compile</span> (<span class="string">'com.facebook.android:facebook-android-sdk:3.23.1'</span>){    
    <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.android'</span>, module: <span class="string">'support-v4'</span>    
}
</code></pre></blockquote>
<h2 id="解决方法">解决方法</h2><p>在添加EventBus的依赖的地方添加如下代码：</p>
<blockquote>
<pre><code><span class="keyword">compile</span> (<span class="string">'de.greenrobot:eventbus:2.0.1'</span>){
    <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.android'</span>, module: <span class="string">'support-v4'</span>
    <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.android'</span>, module: <span class="string">'annotations'</span>
    <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.android'</span>, module: <span class="string">'android-test'</span>
}
</code></pre></blockquote>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/05/23/gralde 循环依赖的问题/" data-id="ciuh05bnj000mu8xp1ay54jb7" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gradle/">gradle</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-listView 闪动的问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/20/listView 闪动的问题/" class="article-date">
  <time datetime="2015-05-20T02:42:24.000Z" itemprop="datePublished">2015-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/20/listView 闪动的问题/">listView 闪动的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我仿做一个网易新闻客户端，因为每一行有不同的内容，所以需要使用getItemViewType来区分不同的行的类型</p>
<p>然而我的东西出现了一个很奇怪的问题：</p>
<blockquote>
<p>在滑动的时候会出现一行快速的闪动（快速变换不同的内容）</p>
</blockquote>
<p>分析问题原因：</p>
<blockquote>
<p>一开始以为我是因为在viewpager里嵌套viewpager惹的祸，<br>或者是使用开源的下拉刷新框架惹的祸，<br>或者是自己使用Viewholder的姿势不对，一开始主要是怀疑getView里面的东西用的不对。</p>
</blockquote>
<p>求证过程：</p>
<blockquote>
<p>我新写一个Activity并没用用到ViewPager，而且我也将原来的adapter的GetView方法重写，由于类型比较多，所以还将变量的名字改变了怕自己哪里写错了。但是依然还是闪动。</p>
</blockquote>
<p>真实的原因：</p>
<blockquote>
<p>然后我就发现我自己的Viewholder里面的组件也是static，因为Viewholder是要复用的，所以需要为static的，但是如果把里面的元素也写成是static的就会有问题。就像上面那样的闪动的问题。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2015/05/20/listView 闪动的问题/" data-id="ciuh05bnm000pu8xp90r400xr" class="article-share-link">分享到</a>
      

      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">android</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/">android</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design-pattern/">design pattern</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gradle/">gradle</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sourcecode-analyze/">sourcecode analyze</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/">test</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/thoughts/">thoughts</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/android/" style="font-size: 20px;">android</a> <a href="/tags/design-pattern/" style="font-size: 17.5px;">design pattern</a> <a href="/tags/git/" style="font-size: 12.5px;">git</a> <a href="/tags/gradle/" style="font-size: 10px;">gradle</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/sourcecode-analyze/" style="font-size: 10px;">sourcecode analyze</a> <a href="/tags/test/" style="font-size: 12.5px;">test</a> <a href="/tags/thoughts/" style="font-size: 10px;">thoughts</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">六月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">五月 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">四月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">九月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/19/Fragment的创建和管理/">Fragment的创建和管理</a>
          </li>
        
          <li>
            <a href="/2015/10/03/java线程池和对象池/">java线程池和对象池</a>
          </li>
        
          <li>
            <a href="/2015/09/29/android插件化开发/">android插件化开发</a>
          </li>
        
          <li>
            <a href="/2015/09/29/RadioGroup-check-的坑/">RadioGroup.check()的坑</a>
          </li>
        
          <li>
            <a href="/2015/08/18/java-io/">java io</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://xiguabaobao.com" target="_blank">主题作者</a>
          </li>
        
          <li>
            <a href="http://reqianduan.com" target="_blank">热前端</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 ironman<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
    </br>本站总访问量<span id="busuanzi_value_site_pv"></span>次,本站访客数<span id="busuanzi_value_site_uv"></span>人次,本文总阅读量<span id="busuanzi_value_page_pv"></span>次
  </div>
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->


<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
