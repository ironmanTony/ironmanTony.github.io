<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[ironmantony]]></title>
  <subtitle><![CDATA[不要想着远处的路有多远，要知道你是在走一小步，你能办到的！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com//"/>
  <updated>2015-10-03T11:23:02.418Z</updated>
  <id>http://yoursite.com//</id>
  
  <author>
    <name><![CDATA[ironman]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[java线程池和对象池]]></title>
    <link href="http://yoursite.com/2015/10/03/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
    <id>http://yoursite.com/2015/10/03/java线程池和对象池/</id>
    <published>2015-10-03T11:11:21.000Z</published>
    <updated>2015-10-03T11:23:02.418Z</updated>
    <content type="html"><![CDATA[<h1 id="java线程池">java线程池</h1><p>原文链接：（讲的比较详细）<br><a href="http://www.infoq.com/cn/articles/java-threadPool#anch97718" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-threadPool#anch97718</a></p>
<h2 id="线程池的创建">线程池的创建</h2><p>我们可以通过ThreadPoolExecutor来创建一个线程池。<br><figure class="highlight"><figcaption><span>ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;### &#21019;&#24314;&#19968;&#20010;&#32447;&#31243;&#27744;&#38656;&#35201;&#36755;&#20837;&#20960;&#20010;&#21442;&#25968;&#65306;&#10;- corePoolSize&#65288;&#32447;&#31243;&#27744;&#30340;&#22522;&#26412;&#22823;&#23567;&#65289;&#65306;&#24403;&#25552;&#20132;&#19968;&#20010;&#20219;&#21153;&#21040;&#32447;&#31243;&#27744;&#26102;&#65292;&#32447;&#31243;&#27744;&#20250;&#21019;&#24314;&#19968;&#20010;&#32447;&#31243;&#26469;&#25191;&#34892;&#20219;&#21153;&#65292;&#21363;&#20351;&#20854;&#20182;&#31354;&#38386;&#30340;&#22522;&#26412;&#32447;&#31243;&#33021;&#22815;&#25191;&#34892;&#26032;&#20219;&#21153;&#20063;&#20250;&#21019;&#24314;&#32447;&#31243;&#65292;&#31561;&#21040;&#38656;&#35201;&#25191;&#34892;&#30340;&#20219;&#21153;&#25968;&#22823;&#20110;&#32447;&#31243;&#27744;&#22522;&#26412;&#22823;&#23567;&#26102;&#23601;&#19981;&#20877;&#21019;&#24314;&#12290;&#22914;&#26524;&#35843;&#29992;&#20102;&#32447;&#31243;&#27744;&#30340;prestartAllCoreThreads&#26041;&#27861;&#65292;&#32447;&#31243;&#27744;&#20250;&#25552;&#21069;&#21019;&#24314;&#24182;&#21551;&#21160;&#25152;&#26377;&#22522;&#26412;&#32447;&#31243;&#12290;&#10;- runnableTaskQueue&#65288;&#20219;&#21153;&#38431;&#21015;&#65289;&#65306;&#29992;&#20110;&#20445;&#23384;&#31561;&#24453;&#25191;&#34892;&#30340;&#20219;&#21153;&#30340;&#38459;&#22622;&#38431;&#21015;&#12290; &#21487;&#20197;&#36873;&#25321;&#20197;&#19979;&#20960;&#20010;&#38459;&#22622;&#38431;&#21015;&#12290;&#10;&#9;- ArrayBlockingQueue&#65306;&#26159;&#19968;&#20010;&#22522;&#20110;&#25968;&#32452;&#32467;&#26500;&#30340;&#26377;&#30028;&#38459;&#22622;&#38431;&#21015;&#65292;&#27492;&#38431;&#21015;&#25353; FIFO&#65288;&#20808;&#36827;&#20808;&#20986;&#65289;&#21407;&#21017;&#23545;&#20803;&#32032;&#36827;&#34892;&#25490;&#24207;&#12290;&#10;&#9;- LinkedBlockingQueue&#65306;&#19968;&#20010;&#22522;&#20110;&#38142;&#34920;&#32467;&#26500;&#30340;&#38459;&#22622;&#38431;&#21015;&#65292;&#27492;&#38431;&#21015;&#25353;FIFO &#65288;&#20808;&#36827;&#20808;&#20986;&#65289; &#25490;&#24207;&#20803;&#32032;&#65292;&#21534;&#21520;&#37327;&#36890;&#24120;&#35201;&#39640;&#20110;ArrayBlockingQueue&#12290;&#38745;&#24577;&#24037;&#21378;&#26041;&#27861;Executors.newFixedThreadPool()&#20351;&#29992;&#20102;&#36825;&#20010;&#38431;&#21015;&#12290;&#10;&#9;- SynchronousQueue&#65306;&#19968;&#20010;&#19981;&#23384;&#20648;&#20803;&#32032;&#30340;&#38459;&#22622;&#38431;&#21015;&#12290;&#27599;&#20010;&#25554;&#20837;&#25805;&#20316;&#24517;&#39035;&#31561;&#21040;&#21478;&#19968;&#20010;&#32447;&#31243;&#35843;&#29992;&#31227;&#38500;&#25805;&#20316;&#65292;&#21542;&#21017;&#25554;&#20837;&#25805;&#20316;&#19968;&#30452;&#22788;&#20110;&#38459;&#22622;&#29366;&#24577;&#65292;&#21534;&#21520;&#37327;&#36890;&#24120;&#35201;&#39640;&#20110;LinkedBlockingQueue&#65292;&#38745;&#24577;&#24037;&#21378;&#26041;&#27861;Executors.newCachedThreadPool&#20351;&#29992;&#20102;&#36825;&#20010;&#38431;&#21015;&#12290;&#10;&#9;- PriorityBlockingQueue&#65306;&#19968;&#20010;&#20855;&#26377;&#20248;&#20808;&#32423;&#30340;&#26080;&#38480;&#38459;&#22622;&#38431;&#21015;&#12290;&#10;&#10;- maximumPoolSize&#65288;&#32447;&#31243;&#27744;&#26368;&#22823;&#22823;&#23567;&#65289;&#65306;&#32447;&#31243;&#27744;&#20801;&#35768;&#21019;&#24314;&#30340;&#26368;&#22823;&#32447;&#31243;&#25968;&#12290;&#22914;&#26524;&#38431;&#21015;&#28385;&#20102;&#65292;&#24182;&#19988;&#24050;&#21019;&#24314;&#30340;&#32447;&#31243;&#25968;&#23567;&#20110;&#26368;&#22823;&#32447;&#31243;&#25968;&#65292;&#21017;&#32447;&#31243;&#27744;&#20250;&#20877;&#21019;&#24314;&#26032;&#30340;&#32447;&#31243;&#25191;&#34892;&#20219;&#21153;&#12290;&#20540;&#24471;&#27880;&#24847;&#30340;&#26159;&#22914;&#26524;&#20351;&#29992;&#20102;&#26080;&#30028;&#30340;&#20219;&#21153;&#38431;&#21015;&#36825;&#20010;&#21442;&#25968;&#23601;&#27809;&#20160;&#20040;&#25928;&#26524;&#12290;&#10;- ThreadFactory&#65306;&#29992;&#20110;&#35774;&#32622;&#21019;&#24314;&#32447;&#31243;&#30340;&#24037;&#21378;&#65292;&#21487;&#20197;&#36890;&#36807;&#32447;&#31243;&#24037;&#21378;&#32473;&#27599;&#20010;&#21019;&#24314;&#20986;&#26469;&#30340;&#32447;&#31243;&#35774;&#32622;&#26356;&#26377;&#24847;&#20041;&#30340;&#21517;&#23383;&#12290;&#10;- RejectedExecutionHandler&#65288;&#39281;&#21644;&#31574;&#30053;&#65289;&#65306;&#24403;&#38431;&#21015;&#21644;&#32447;&#31243;&#27744;&#37117;&#28385;&#20102;&#65292;&#35828;&#26126;&#32447;&#31243;&#27744;&#22788;&#20110;&#39281;&#21644;&#29366;&#24577;&#65292;&#37027;&#20040;&#24517;&#39035;&#37319;&#21462;&#19968;&#31181;&#31574;&#30053;&#22788;&#29702;&#25552;&#20132;&#30340;&#26032;&#20219;&#21153;&#12290;&#36825;&#20010;&#31574;&#30053;&#40664;&#35748;&#24773;&#20917;&#19979;&#26159;AbortPolicy&#65292;&#34920;&#31034;&#26080;&#27861;&#22788;&#29702;&#26032;&#20219;&#21153;&#26102;&#25243;&#20986;&#24322;&#24120;&#12290;&#20197;&#19979;&#26159;JDK1.5&#25552;&#20379;&#30340;&#22235;&#31181;&#31574;&#30053;&#12290;&#10;&#9;- AbortPolicy&#65306;&#30452;&#25509;&#25243;&#20986;&#24322;&#24120;&#12290;&#10;&#9;- CallerRunsPolicy&#65306;&#21482;&#29992;&#35843;&#29992;&#32773;&#25152;&#22312;&#32447;&#31243;&#26469;&#36816;&#34892;&#20219;&#21153;&#12290;&#10;&#9;- DiscardOldestPolicy&#65306;&#20002;&#24323;&#38431;&#21015;&#37324;&#26368;&#36817;&#30340;&#19968;&#20010;&#20219;&#21153;&#65292;&#24182;&#25191;&#34892;&#24403;&#21069;&#20219;&#21153;&#12290;&#10;&#9;- DiscardPolicy&#65306;&#19981;&#22788;&#29702;&#65292;&#20002;&#24323;&#25481;&#12290;&#10;&#9;- &#24403;&#28982;&#20063;&#21487;&#20197;&#26681;&#25454;&#24212;&#29992;&#22330;&#26223;&#38656;&#35201;&#26469;&#23454;&#29616;RejectedExecutionHandler&#25509;&#21475;&#33258;&#23450;&#20041;&#31574;&#30053;&#12290;&#22914;&#35760;&#24405;&#26085;&#24535;&#25110;&#25345;&#20037;&#21270;&#19981;&#33021;&#22788;&#29702;&#30340;&#20219;&#21153;&#12290;&#10;&#10;- keepAliveTime&#65288;&#32447;&#31243;&#27963;&#21160;&#20445;&#25345;&#26102;&#38388;&#65289;&#65306;&#32447;&#31243;&#27744;&#30340;&#24037;&#20316;&#32447;&#31243;&#31354;&#38386;&#21518;&#65292;&#20445;&#25345;&#23384;&#27963;&#30340;&#26102;&#38388;&#12290;&#25152;&#20197;&#22914;&#26524;&#20219;&#21153;&#24456;&#22810;&#65292;&#24182;&#19988;&#27599;&#20010;&#20219;&#21153;&#25191;&#34892;&#30340;&#26102;&#38388;&#27604;&#36739;&#30701;&#65292;&#21487;&#20197;&#35843;&#22823;&#36825;&#20010;&#26102;&#38388;&#65292;&#25552;&#39640;&#32447;&#31243;&#30340;&#21033;&#29992;&#29575;&#12290;&#10;- TimeUnit&#65288;&#32447;&#31243;&#27963;&#21160;&#20445;&#25345;&#26102;&#38388;&#30340;&#21333;&#20301;&#65289;&#65306;&#21487;&#36873;&#30340;&#21333;&#20301;&#26377;&#22825;&#65288;DAYS&#65289;&#65292;&#23567;&#26102;&#65288;HOURS&#65289;&#65292;&#20998;&#38047;&#65288;MINUTES&#65289;&#65292;&#27627;&#31186;(MILLISECONDS)&#65292;&#24494;&#31186;(MICROSECONDS, &#21315;&#20998;&#20043;&#19968;&#27627;&#31186;)&#21644;&#27627;&#24494;&#31186;(NANOSECONDS, &#21315;&#20998;&#20043;&#19968;&#24494;&#31186;)&#12290;&#10;&#10;### &#21521;&#32447;&#31243;&#27744;&#25552;&#20132;&#20219;&#21153;&#10;- &#25105;&#20204;&#21487;&#20197;&#20351;&#29992;execute&#25552;&#20132;&#30340;&#20219;&#21153;&#65292;&#20294;&#26159;execute&#26041;&#27861;&#27809;&#26377;&#36820;&#22238;&#20540;&#65292;&#25152;&#20197;&#26080;&#27861;&#21028;&#26029;&#20219;&#21153;&#26159;&#21542;&#34987;&#32447;&#31243;&#27744;&#25191;&#34892;&#25104;&#21151;&#12290;&#36890;&#36807;&#20197;&#19979;&#20195;&#30721;&#21487;&#30693;execute&#26041;&#27861;&#36755;&#20837;&#30340;&#20219;&#21153;&#26159;&#19968;&#20010;Runnable&#31867;&#30340;&#23454;&#20363;&#12290;</span><br></pre></td></tr></table></figure></p>
<p>threadsPool.execute(new Runnable() {<br>            @Override<br>            public void run() {<br>                // TODO Auto-generated method stub<br>            }<br>        });<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 我们也可以使用submit 方法来提交任务，它会返回一个future,那么我们可以通过这个future来判断任务是否执行成功，通过future的<span class="keyword">get</span>方法来获取返回值，<span class="keyword">get</span>方法会阻塞住直到任务完成，而使用`<span class="keyword">get</span>(long <span class="keyword">timeout</span>, TimeUnit unit)`方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</span><br></pre></td></tr></table></figure></p>
<p>Future<object> future = executor.submit(harReturnValuetask);<br>try {<br>     Object s = future.get();<br>} catch (InterruptedException e) {<br>    // 处理中断异常<br>} catch (ExecutionException e) {<br>    // 处理无法执行任务异常<br>} finally {<br>    // 关闭线程池<br>    executor.shutdown();<br>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="header">## 线程池的关闭</span></span><br><span class="line">我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，<span class="code">`shutdownNow`</span>首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</span><br><span class="line">只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。</span><br><span class="line"></span><br><span class="line"><span class="header">## 线程池的分析</span></span><br><span class="line"><span class="bullet">- </span>流程分析：线程池的主要工作流程如下图：</span><br><span class="line">![](/imgs/threadpool.jpg)</span><br><span class="line"></span><br><span class="line">从上图我们可以看出，当提交一个新任务到线程池时，线程池的处理流程如下：</span><br><span class="line"><span class="bullet">1. </span>首先线程池判断基本线程池是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。</span><br><span class="line"><span class="bullet">2. </span>其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</span><br><span class="line"><span class="bullet">3. </span>最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>源码分析。上面的流程分析让我们很直观的了解了线程池的工作原理，让我们再通过源代码来看看是如何实现的。线程池执行任务的方法如下：</span><br></pre></td></tr></table></figure></object></p>
<p>public void execute(Runnable command) {<br>    if (command == null)<br>       throw new NullPointerException();<br>    //如果线程数小于基本线程数，则创建线程并执行当前任务<br>    if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) {<br>    //如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。<br>        if (runState == RUNNING &amp;&amp; workQueue.offer(command)) {<br>            if (runState != RUNNING || poolSize == 0)<br>                      ensureQueuedTaskHandled(command);<br>        }<br>    //如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，<br>则创建一个线程执行任务。<br>        else if (!addIfUnderMaximumPoolSize(command))<br>        //抛出RejectedExecutionException异常<br>            reject(command); // is shutdown or saturated<br>    }<br>}<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工作线程。线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。我们可以从Worker的<span class="command">run</span>方法里看到这点：</span><br></pre></td></tr></table></figure></p>
<p>public void run() {<br>     try {<br>           Runnable task = firstTask;<br>           firstTask = null;<br>            while (task != null || (task = getTask()) != null) {<br>                    runTask(task);<br>                    task = null;<br>            }<br>      } finally {<br>             workerDone(this);<br>      }<br>}<br>```</p>
<h3 id="如何复用线程：">如何复用线程：</h3><p>从上面也可以看出来：<br>是通过无限循环获取工作队列里的任务来执行，并且在自己的run方法中直接调用Runnable.run()方法，这样并没有开启新的线程，而是处理了我们提交的线程里需要执行的任务，这样就达到了复用线程的目的了。</p>
<hr>
<h1 id="对象池：">对象池：</h1><h2 id="参考资料：">参考资料：</h2><p><a href="http://www.cnblogs.com/rubylouvre/p/3314775.html" target="_blank" rel="external">http://www.cnblogs.com/rubylouvre/p/3314775.html</a></p>
<h2 id="对象池的作用：">对象池的作用：</h2><p>限制一个类的对象的个数，（单例是限制了一个类只能有一个实例，对象池则是限制一个类实例的个数）</p>
<h2 id="实现方式：">实现方式：</h2><p>也是跟线程池差不多，在创建新对象的时候去判断是重新创建还是去池里取还是等待，从而达到复用对象的功能。这里重新创建和等待都很好理解，那么如何判断一个已经创建的对象是否可用呢？这就需要使用方在用完这个对象的时候去将这个对象设置为空闲，也就是相当于手动释放。理解了这个，对象池还是很好理解的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="java线程池">java线程池</h1><p>原文链接：（讲的比较详细）<br><a href="http://www.infoq.com/cn/articles/java-threadPool#anch97718" target="_blank" rel="e]]>
    </summary>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android插件化开发]]></title>
    <link href="http://yoursite.com/2015/09/29/android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2015/09/29/android插件化开发/</id>
    <published>2015-09-29T14:54:52.000Z</published>
    <updated>2015-10-03T07:52:13.366Z</updated>
    <content type="html"><![CDATA[<p>昨天一不小心搞出一个bug，而且还是崩溃，但是很快我就找到了原因，并且修复了bug提交了代码，一会儿qa马上热发了一版，这样我的崩溃问题就解决了，这也太快了！Android更新不是要先发应用市场，然后等待好几周的审核，然后有的用户还不肯更新吗？这里面到底用到了什么黑科技？于是我想知道android热发的原理，开始查android热发，没有找到什么有价值的东西，后来搜android 组件化开发，在知乎上找到一篇，回答很简单，但是有一个链接到他详细博客的地址<a href="http://www.trinea.cn/android/android-plugin/" target="_blank" rel="external">http://www.trinea.cn/android/android-plugin/</a> ，根据博客里面提供的信息，我了解了几个开源框架是如何实现热加载，或者说是热发的。</p>
<hr>
<h2 id="热发的过程：">热发的过程：</h2><ol>
<li>apk插件更新：通过差分（bsdiff），来更新需要更新的apk插件，最小化用户的下载量。</li>
<li>宿主程序动态加载更新之后的apk插件，完成热发。</li>
</ol>
<hr>
<h2 id="组件开发的概念：">组件开发的概念：</h2><blockquote>
<p>宿主程序通过ClassLoader去动态加载apk文件并将其放在自己的进程中执行。</p>
</blockquote>
<hr>
<h2 id="基本概念理解资料：">基本概念理解资料：</h2><ul>
<li>ClassLoader：<br><a href="http://www.trinea.cn/android/java-loader-common-class/" target="_blank" rel="external">http://www.trinea.cn/android/java-loader-common-class/</a><br><a href="http://android-developers.blogspot.hk/2011/07/custom-class-loading-in-dalvik.html" target="_blank" rel="external">http://android-developers.blogspot.hk/2011/07/custom-class-loading-in-dalvik.html</a>  （进阶）    </li>
<li>AndroidApk动态加载机制<br><a href="http://blog.csdn.net/singwhatiwanna/article/details/22597587" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/22597587</a><br><a href="http://blog.csdn.net/singwhatiwanna/article/details/23387079" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/23387079</a></li>
<li>开源项目dl的介绍：<br><a href="http://blog.csdn.net/singwhatiwanna/article/details/39937639" target="_blank" rel="external">http://blog.csdn.net/singwhatiwanna/article/details/39937639</a></li>
</ul>
<hr>
<h2 id="组件开发的好处：">组件开发的好处：</h2><ul>
<li>动态更新。不用频繁卸载安装apk程序。</li>
<li>可以多个项目同时开发，减少apk的大小，并且每个项目可以同时进行，减少编译时间等等。</li>
</ul>
<hr>
<h2 id="组件开发需要解决的问题：">组件开发需要解决的问题：</h2><p><a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">https://github.com/singwhatiwanna/dynamic-load-apk</a> 这个很好地解释了为什么会有这两个问题</p>
<ol>
<li><p>Activity生命周期的管理。</p>
<blockquote>
<p>apk被宿主程序调起以后，apk中的activity其实就是一个普通的对象，不具有activity的性质 ，因为系统启动activity是要做很多初始化工作的，而我们在应用层通过反射去启动activity是很难完成系统所做的初始化工作的，所以activity的大部分特性都无法使用包括activity的生命周期管理，这就需要我们自己去管理。</p>
</blockquote>
</li>
<li><p>资源的访问。</p>
<blockquote>
<p>我们知道，宿主程序调起未安装的apk，一个很大的问题就是资源如何访问，具体来说就是，凡是以R开头的资源都不能访问了，因为宿主程序中并没有apk中的资源，所以通过R来加载资源是行不通的，程序会报错：无法找到某某id所对应的资源。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="几种动态加载开源项目的实现：">几种动态加载开源项目的实现：</h2><p>原文链接：<a href="http://www.trinea.cn/android/android-plugin/" target="_blank" rel="external">http://www.trinea.cn/android/android-plugin/</a>    </p>
<ol>
<li><p>DynamicLoadApk<br>GitHub：<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">https://github.com/singwhatiwanna/dynamic-load-apk</a><br>这个项目实现了一部分的动态加载，原理是 DexClassLoader 加 Activity 代理，可以看看。即在容器中注册几个代理的 Activity，启动插件的 Activity 时实际启动的都是代理的 Activity，这样就解决了 Activity 必须注册的问题。<br>当然这个项目里也有不少问题没解决，有兴趣可以加入他们。  </p>
</li>
<li><p>AndroidDynamicLoader GitHub：<a href="https://github.com/mmin18/AndroidDynamicLoader" target="_blank" rel="external">https://github.com/mmin18/AndroidDynamicLoader</a><br>这是点评一个工程师介绍的方式，和上面不同的是：他不是用代理 Activity 的方式实现而是用 Fragment 以及 schema 的方式实现  </p>
</li>
<li><p>Android PluginManager GitHub：<a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">https://github.com/houkx/android-pluginmgr</a><br>这个项目的原理实际也是 DexClassLoader 加 Activity 代理，不同的是上面的 dynamic-load-apk 项目中，插件需要依赖框架的 lib，插件组件继承框架 lib 的 Base 组件。而这个框架通过字节码操作动态生成一个子类去继承插件组件解决插件必须依赖框架的问题，从而达到插件无需做任何改动(理论上)即可加载的效果。</p>
</li>
</ol>
<p>最近的：</p>
<ul>
<li><p>淘宝的 Atlas现在更名为ACDD<br><a href="https://github.com/bunnyblue/ACDD" target="_blank" rel="external">https://github.com/bunnyblue/ACDD</a><br><a href="https://github.com/bunnyblue/ACDDExtension" target="_blank" rel="external">https://github.com/bunnyblue/ACDDExtension</a></p>
</li>
<li><p>360 的 DroidPlugin<br><a href="https://github.com/Qihoo360/DroidPlugin" target="_blank" rel="external">https://github.com/Qihoo360/DroidPlugin</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>昨天一不小心搞出一个bug，而且还是崩溃，但是很快我就找到了原因，并且修复了bug提交了代码，一会儿qa马上热发了一版，这样我的崩溃问题就解决了，这也太快了！Android更新不是要先发应用市场，然后等待好几周的审核，然后有的用户还不肯更新吗？这里面到底用到了什么黑科技？于]]>
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RadioGroup.check()的坑]]></title>
    <link href="http://yoursite.com/2015/09/29/RadioGroup-check-%E7%9A%84%E5%9D%91/"/>
    <id>http://yoursite.com/2015/09/29/RadioGroup-check-的坑/</id>
    <published>2015-09-29T03:40:43.000Z</published>
    <updated>2015-10-03T04:59:24.273Z</updated>
    <content type="html"><![CDATA[<h3 id="问题描述：">问题描述：</h3><p>我使用RadioGroup.check()方法来初始化radioGroup，然后我在onCheckedChanged()里去根据选择的radioButton来发送网络请求，并且新建fragment。这时候我发现一个问题：这个radiobutton下的网络请求会发送两次，而且fragment也会创建两次，而且那个新建的fragment里还有很多的初始化过程和网络请求，所以会让用户一直处在等待的状态。</p>
<p>开始时候各种找原因，以为是我在哪里调用了太多次，还是共用layout文件有相同的id所以被别的地方的调用影响了？都不是，最后在stackoverflow上找到了答案：使用RadioGroup.check()会调用onCheckedChanged()方法三次，而我在onCheckedChanged()方法里判断了调用的是哪个id，然后发送请求创建fragmeng，所以只调用了两次。</p>
<h3 id="statckoverflow原文链接：">statckoverflow原文链接：</h3><p><a href="http://stackoverflow.com/questions/10263778/radiogroup-calls-oncheckchanged-three-times" target="_blank" rel="external">http://stackoverflow.com/questions/10263778/radiogroup-calls-oncheckchanged-three-times</a></p>
<p><img src="/imgs/radiogroupChecks.png" alt=""></p>
<h3 id="RadioGroup-check()源码如下：">RadioGroup.check()源码如下：</h3><p><a href="http://www.grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.1.1_r1/android/widget/RadioGroup.java#RadioGroup.check%28int%29" target="_blank" rel="external">http://www.grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.1.1_r1/android/widget/RadioGroup.java#RadioGroup.check%28int%29</a></p>
<p><img src="/imgs/radiogroup2.png" alt=""></p>
<h3 id="解决方法_：">解决方法 ：</h3><p>使用radioBotton.setChecked()方法来解决</p>
<p><img src="/imgs/radiogroup3.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="问题描述：">问题描述：</h3><p>我使用RadioGroup.check()方法来初始化radioGroup，然后我在onCheckedChanged()里去根据选择的radioButton来发送网络请求，并且新建fragment。这时候我发现一个问题：这个]]>
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[java io]]></title>
    <link href="http://yoursite.com/2015/08/18/java-io/"/>
    <id>http://yoursite.com/2015/08/18/java-io/</id>
    <published>2015-08-18T08:36:20.000Z</published>
    <updated>2015-10-03T07:44:58.333Z</updated>
    <content type="html"><![CDATA[<h2 id="java_io继承关系图：">java io继承关系图：</h2><p><img src="/imgs/java-io.png" alt=""></p>
<h2 id="inputStream_vs_Reader">inputStream vs Reader</h2><p><a href="http://stackoverflow.com/questions/4367539/what-is-the-difference-between-reader-and-inputstream" target="_blank" rel="external">http://stackoverflow.com/questions/4367539/what-is-the-difference-between-reader-and-inputstream</a><br>An InputStream is the raw method of getting information from a resource. It grabs the data byte by byte without performing any kind of translation. If you are reading image data, or any binary file, this is the stream to use.<br>A Reader is designed for character streams. If the information you are reading is all text, then the Reader will take care of the character decoding for you and give you unicode characters from the raw input stream. If you are reading any type of text, this is the stream to use.<br>You can wrap an InputStream and turn it into a Reader by using the InputStreamReader class.<br><code>Reader reader = new InputStreamReader(inputStream);</code></p>
<h2 id="solution:">solution:</h2><p>如果是读取字符类文件，可以使用Reader和Writer，不用担心编码问题。<br>如果是读取二进制文件，图片等等可以使用InputStream和OutputStream。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="java_io继承关系图：">java io继承关系图：</h2><p><img src="/imgs/java-io.png" alt=""></p>
<h2 id="inputStream_vs_Reader">inputStream vs Reader</h]]>
    </summary>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[some useful git command]]></title>
    <link href="http://yoursite.com/2015/08/18/some-useful-git-command/"/>
    <id>http://yoursite.com/2015/08/18/some-useful-git-command/</id>
    <published>2015-08-18T08:35:10.000Z</published>
    <updated>2015-10-03T07:45:18.310Z</updated>
    <content type="html"><![CDATA[<h2 id="不提交一个文件（已经在仓库中，并且不想将远程仓库中的文件删除）在本地的改变">不提交一个文件（已经在仓库中，并且不想将远程仓库中的文件删除）在本地的改变</h2><h3 id="GIT:_ignoring_changes_in_tracked_files29/01/2009">GIT: ignoring changes in tracked files29/01/2009</h3><p>There may be times when you want to edit some variables in for example a database connection file, to run an application right from within your GIT repo. Of course you don’t wont those changes to be commited, so you add the file the .gitignore.<br>However adding tracked files to .gitignore won’t work because GIT will still track the changes and commit the file if you use the -a parameter.<br>Fortunately GIT has a very easy solution for this, just run the following command on the file or path you want to ignore the changes of:</p>
<blockquote>
<p><code>git update-index --assume-unchanged &lt;file&gt;</code>    </p>
</blockquote>
<p>If you wanna start tracking changes again run the following command:</p>
<blockquote>
<p><code>git update-index --no-assume-unchanged &lt;file&gt;</code></p>
</blockquote>
<h3 id="参考资料：">参考资料：</h3><p><a href="http://blog.pagebakers.nl/2009/01/29/git-ignoring-changes-in-tracked-files/" target="_blank" rel="external">http://blog.pagebakers.nl/2009/01/29/git-ignoring-changes-in-tracked-files/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="不提交一个文件（已经在仓库中，并且不想将远程仓库中的文件删除）在本地的改变">不提交一个文件（已经在仓库中，并且不想将远程仓库中的文件删除）在本地的改变</h2><h3 id="GIT:_ignoring_changes_in_tracked_files29/01]]>
    </summary>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AysncTask源码解析]]></title>
    <link href="http://yoursite.com/2015/08/06/AysncTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2015/08/06/AysncTask源码解析/</id>
    <published>2015-08-06T08:03:13.000Z</published>
    <updated>2015-10-03T04:42:34.670Z</updated>
    <content type="html"><![CDATA[<h2 id="AsyncTask的类图">AsyncTask的类图</h2><p><img src="/imgs/asynctask.png" alt=""></p>
<ul>
<li>其中，如果使用默认的Executor其实AsyncTask中的任务是一个一个执行的。<br>其中灰色的是接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">    Runnable mActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.run();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    scheduleNext();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这段代码中可以看出来。<br>如果使用Thread_pool_executor那么就会使用线程池来执行你的task。<br>注释中也有：</p>
<p>Order of execution</p>
<p>When first introduced, AsyncTasks were executed serially on a single background<br>thread. Starting with {android.os.Build.VERSION_CODES#DONUT}, this was changed<br>to a pool of threads allowing multiple tasks to operate in parallel. Starting with<br>android.os.Build.VERSION_CODES#HONEYCOMB, tasks are executed on a single<br>thread to avoid common application errors caused by parallel execution</p>
<p> If you truly want parallel execution, you can invoke<br>executeOnExecutor(java.util.concurrent.Executor, Object[])} with<br>THREAD_POOL_EXECUTOR</p>
<ul>
<li><p>从类图可以看出来AsyncTask主要使用了组合的方式来使用代码。</p>
</li>
<li><p>理解代码的一个方式是画类图，然后找一个入口然后看下去，看他是如何调用的。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="AsyncTask的类图">AsyncTask的类图</h2><p><img src="/imgs/asynctask.png" alt=""></p>
<ul>
<li>其中，如果使用默认的Executor其实AsyncTask中的任务是一个一个执行的。<br>]]>
    </summary>
    
      <category term="sourcecode analyze" scheme="http://yoursite.com/tags/sourcecode-analyze/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[idea上一些实用的快捷键]]></title>
    <link href="http://yoursite.com/2015/06/17/idea%E4%B8%8A%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2015/06/17/idea上一些实用的快捷键/</id>
    <published>2015-06-17T08:37:43.000Z</published>
    <updated>2015-10-03T07:44:39.395Z</updated>
    <content type="html"><![CDATA[<p>这里列出的是我自认为使用比较多比较实用的一些，并不全，如果想看全的，可以推荐这一篇：<br><a href="http://www.cnblogs.com/tonycody/p/3257601.html" target="_blank" rel="external">http://www.cnblogs.com/tonycody/p/3257601.html</a></p>
<ul>
<li><p>ctrl + P<br>列出参数列表（使用比较多 ）</p>
</li>
<li><p>ctrl + shift + enter<br>当在括号里输入完最后一个参数时候他会直接光标跳到最后并且添加分号，不需要自己按向左键移动光标。（使用比较多 ）<br>ctrl + enter 向下插入一行，光标位置不变</p>
</li>
<li><p>shift + enter<br>向下插入一行。光标位置进入下一行（可以在一行的任何位置换行，而不必将光标移动到行尾，使用比较多）</p>
</li>
<li><p>ctrl+left/right<br>在单词间跳动光标，基本在所有的编辑器中都是适用 （使用比较多 ）</p>
</li>
<li><p>ctr+shitf+left/right<br>快速选中，基本在所有的编辑器中都是适用（shift选中，ctrl+left/right在单词中快速跳动，使用比较多 ）</p>
</li>
<li><p>Alt+left/right，切换代码视图（使用比较多 ）</p>
</li>
<li><p>Alt+Up/Down，在方法间快速移动定位（使用比较多 ）</p>
</li>
<li><p>F2 或 Shift+F2，高亮错误或警告快速定位（使用比较多）</p>
</li>
<li><p>Ctrl+Alt+T<br>可以把代码包在一个块内，例如：try/catch（使用比较多 ）</p>
</li>
<li><p>Ctrl+F，处于查找状态下按down向下查找，up向上查找（使用比较多）</p>
</li>
<li><p>Ctrl+F12，可以显示当前文件的结构（快速查找当前类中某个方法，使用比较多）</p>
</li>
<li><p>Ctrl+Shift+W，取消选择光标所在词（使用比较多）</p>
</li>
<li>Ctrl+[ OR ]，可以跑到大括号的开头与结尾</li>
<li><p>Ctrl+Shift +[ OR ]，选择大括号中的内容</p>
</li>
<li><p>alt + 1 同上（在工程目录和编辑页面间切换，使用比较多）</p>
</li>
<li><p>Ctrl+Alt+O，优化导入的类和包(去掉没有使用的import，使用比较多 )</p>
</li>
<li><p>Shift+F6，重构 - 重命名（使用比较多 ）</p>
</li>
<li><p>Ctrl+G，定位行</p>
</li>
<li><p>Ctrl+H，显示类结构图（类的继承层次）</p>
</li>
<li><p>Ctrl+U，转到父类</p>
</li>
<li><p>Ctrl+”+/-“，当前方法展开、折叠</p>
</li>
<li><p>Ctrl+Shift+”+/-“，全部展开、折叠</p>
</li>
<li><p>Ctrl+Shift+J，整合两行</p>
</li>
<li><p>ctrl + shift + space<br>当new 一个变量的时候，已经写了变量类型，打了等号之后按这个可以快速完成。</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里列出的是我自认为使用比较多比较实用的一些，并不全，如果想看全的，可以推荐这一篇：<br><a href="http://www.cnblogs.com/tonycody/p/3257601.html" target="_blank" rel="external">htt]]>
    </summary>
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gralde 循环依赖的问题]]></title>
    <link href="http://yoursite.com/2015/05/23/gralde%20%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2015/05/23/gralde 循环依赖的问题/</id>
    <published>2015-05-23T02:42:24.000Z</published>
    <updated>2015-10-03T04:41:26.964Z</updated>
    <content type="html"><![CDATA[<p>今天遇到一个问题，添加一个EventBus依赖包之后运行一直报：‘java.exe finished with non-zero exit value 2 ’</p>
<p>在statckoverflow上找到了问题的答案：</p>
<blockquote>
<p>First of all you should try to list your dependencies with gradle :MODULE:dependencies Check if there are libraries conflicts ( same library but different version ). In this case i supose you should exclude support library module from Facebook SDK.</p>
<pre><code><span class="keyword">compile</span> (<span class="string">'com.facebook.android:facebook-android-sdk:3.23.1'</span>){    
    <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.android'</span>, module: <span class="string">'support-v4'</span>    
}
</code></pre></blockquote>
<h2 id="解决方法">解决方法</h2><p>在添加EventBus的依赖的地方添加如下代码：</p>
<blockquote>
<pre><code><span class="keyword">compile</span> (<span class="string">'de.greenrobot:eventbus:2.0.1'</span>){
    <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.android'</span>, module: <span class="string">'support-v4'</span>
    <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.android'</span>, module: <span class="string">'annotations'</span>
    <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.google.android'</span>, module: <span class="string">'android-test'</span>
}
</code></pre></blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天遇到一个问题，添加一个EventBus依赖包之后运行一直报：‘java.exe finished with non-zero exit value 2 ’</p>
<p>在statckoverflow上找到了问题的答案：</p>
<blockquote>
<p>Firs]]>
    </summary>
    
      <category term="gradle" scheme="http://yoursite.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[listView 闪动的问题]]></title>
    <link href="http://yoursite.com/2015/05/20/listView%20%E9%97%AA%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2015/05/20/listView 闪动的问题/</id>
    <published>2015-05-20T02:42:24.000Z</published>
    <updated>2015-10-03T04:41:14.160Z</updated>
    <content type="html"><![CDATA[<p>我仿做一个网易新闻客户端，因为每一行有不同的内容，所以需要使用getItemViewType来区分不同的行的类型</p>
<p>然而我的东西出现了一个很奇怪的问题：</p>
<blockquote>
<p>在滑动的时候会出现一行快速的闪动（快速变换不同的内容）</p>
</blockquote>
<p>分析问题原因：</p>
<blockquote>
<p>一开始以为我是因为在viewpager里嵌套viewpager惹的祸，<br>或者是使用开源的下拉刷新框架惹的祸，<br>或者是自己使用Viewholder的姿势不对，一开始主要是怀疑getView里面的东西用的不对。</p>
</blockquote>
<p>求证过程：</p>
<blockquote>
<p>我新写一个Activity并没用用到ViewPager，而且我也将原来的adapter的GetView方法重写，由于类型比较多，所以还将变量的名字改变了怕自己哪里写错了。但是依然还是闪动。</p>
</blockquote>
<p>真实的原因：</p>
<blockquote>
<p>然后我就发现我自己的Viewholder里面的组件也是static，因为Viewholder是要复用的，所以需要为static的，但是如果把里面的元素也写成是static的就会有问题。就像上面那样的闪动的问题。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>我仿做一个网易新闻客户端，因为每一行有不同的内容，所以需要使用getItemViewType来区分不同的行的类型</p>
<p>然而我的东西出现了一个很奇怪的问题：</p>
<blockquote>
<p>在滑动的时候会出现一行快速的闪动（快速变换不同的内容）</p>
</]]>
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于git的几个问题]]></title>
    <link href="http://yoursite.com/2015/05/05/git%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2015/05/05/git的几个问题/</id>
    <published>2015-05-05T02:42:24.000Z</published>
    <updated>2015-10-03T05:10:15.796Z</updated>
    <content type="html"><![CDATA[<h2 id="git_merge和git_rebase区别：">git merge和git rebase区别：</h2><p>这个文件写的很清楚<br><a href="http://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88" target="_blank" rel="external">http://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88</a>     </p>
<h2 id="git_fetch和git_pull区别：">git fetch和git pull区别：</h2><p>其实git pull相当于：git fetch , git merge<br><a href="http://stackoverflow.com/questions/292357/what-are-the-differences-between-git-pull-and-git-fetch" target="_blank" rel="external">http://stackoverflow.com/questions/292357/what-are-the-differences-between-git-pull-and-git-fetch</a>    </p>
<h2 id="到底是应该使用git_pull_还是_git_pull_—rebase_?">到底是应该使用git pull 还是 git pull —rebase ?</h2><p>我个人赞同使用git pull —rebase,因为如果多个人开发并且经常pull的话，就会出现很多：<code>Merge branch &#39;aaa&#39; of git.xxx.xxx/xxx/xxx into aaa</code>这样的commit。<br>就像这里的讨论：<a href="https://ruby-china.org/topics/112" target="_blank" rel="external">https://ruby-china.org/topics/112</a></p>
<h2 id="我们使用的工作流【集中式工作流】：">我们使用的工作流【集中式工作流】：</h2><p><a href="http://git-scm.com/book/zh/v1/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" target="_blank" rel="external">http://git-scm.com/book/zh/v1/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B</a><br>通常，集中式工作流程使用的都是单点协作模型。一个存放代码仓库的中心服务器，可以接受所有开发者提交的代码。所有的开发者都是普通的节点，作为中心集线器的消费者，平时的工作就是和中心仓库同步数据（见图 5-1）。  </p>
<p><img src="/imgs/workflow.png" alt="workflow.png"></p>
<p>如果两个开发者从中心仓库克隆代码下来，同时作了一些修订，那么只有第一个开发者可以顺利地把数据推送到共享服务器。第二个开发者在提交他的修订之前，必须先下载合并服务器上的数据，解决冲突之后才能推送数据到共享服务器上。在 Git 中这么用也决无问题，这就好比是在用 Subversion（或其他 CVCS）一样，可以很好地工作。<br>如果你的团队不是很大，或者大家都已经习惯了使用集中式工作流程，完全可以采用这种简单的模式。只需要配置好一台中心服务器，并给每个人推送数据的权限，就可以开展工作了。<strong>但如果提交代码时有冲突， Git 根本就不会让用户覆盖他人代码，它直接驳回第二个人的提交操作。这就等于告诉提交者，你所作的修订无法通过快进（fast-forward）来合并，你必须先拉取最新数据下来，手工解决冲突合并后，才能继续推送新的提交</strong>。 绝大多数人都熟悉和了解这种模式的工作方式，所以使用也非常广泛。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="git_merge和git_rebase区别：">git merge和git rebase区别：</h2><p>这个文件写的很清楚<br><a href="http://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%]]>
    </summary>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用monkey对app进行压力测试]]></title>
    <link href="http://yoursite.com/2015/05/04/%E4%BD%BF%E7%94%A8monkey%E5%AF%B9app%E8%BF%9B%E8%A1%8C%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2015/05/04/使用monkey对app进行压力测试/</id>
    <published>2015-05-04T02:42:24.000Z</published>
    <updated>2015-10-03T04:41:37.166Z</updated>
    <content type="html"><![CDATA[<p>其实monkey压力测试也不需要怎么去配置，只是有一些参数。</p>
<hr>
<ul>
<li><p>使用adb shell来连接一个模拟器或者真机。<br>直接adb shell</p>
</li>
<li><p>使用monkey -p packagename -v times 随机生成times个event来测试packagename的default界面。     </p>
<blockquote>
<p>比如：monkey -p com.tencent.mobileqq -v 5000<br>对qq来进行压力测试。</p>
</blockquote>
<p>或者monkey -p packagename —pct-touch 100 -v times。<code>-v times</code>是一定要带上的。</p>
</li>
</ul>
<hr>
<h2 id="这些命令都简单，但是我现在想要获取到qq的包名。">这些命令都简单，但是我现在想要获取到qq的包名。</h2><p>使用命令<code>pm list packages -f</code>就可以获取到设备上所有已经安装的包名。<br>这样就获取到qq的包名为：com.tencent.mobileqq<br>这样我就可以使用monkey来玩qq了。     </p>
<hr>
<p>本来想用这种方式来测试一下是否可以用monkey来抢微信红包，<br>然后我就运行了<code>monkey -p com.tencent.mm --pct-touch 100 -v 2000</code>结果加了好多好友而且还没有发送成功。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实monkey压力测试也不需要怎么去配置，只是有一些参数。</p>
<hr>
<ul>
<li><p>使用adb shell来连接一个模拟器或者真机。<br>直接adb shell</p>
</li>
<li><p>使用monkey -p packagename -v t]]>
    </summary>
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于如何解决一个问题]]></title>
    <link href="http://yoursite.com/2015/05/01/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2015/05/01/关于如何解决一个问题/</id>
    <published>2015-05-01T02:42:24.000Z</published>
    <updated>2015-10-03T04:41:04.334Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="一定要在搜索列表页面去筛选！包括看那些小的字。">一定要在搜索列表页面去筛选！包括看那些小的字。</h2><p>在网页列表里去筛选比进入网页内容然后发现他不是这个东西花的时间要少得多。<br>比如需要搜索windows下管理多个git ssh的问题，那么一定要注意关键字<code>多个账号</code>，无关的网页不要进，不然可能浪费大多数时间。</p>
<hr>
<h2 id="进入网页之后要学会使用查找来找到自己想要的东西。">进入网页之后要学会使用查找来找到自己想要的东西。</h2><p>可能打开的网页很长，这个时候用ctr + f 比自己的肉眼看要快很多。</p>
<hr>
<h2 id="一定要有一个自己处理这个事情的解决方案、步骤。">一定要有一个自己处理这个事情的解决方案、步骤。</h2><p>解决一个问题不是看谁会搜索，在任何想到准确的解决方案之前的搜索都是浪费时间。</p>
<hr>
<h2 id="解决一个问题一定要一针见血。请直面问题！！！">解决一个问题一定要一针见血。请直面问题！！！</h2><p>我发现我有一个毛病，解决一个问题总是喜欢围绕着问题去转。比如需要写一markdown格式的博客，然后我就找了整个markdown语法的文章来读，但是我要知道我想要做的是写博客啊，不是学习markdown语法。<br>可能这个是很轻的问题，但是有很多时候确实我围绕问题转的毛病太多，需要解决的问题是这个，但是我总是在研究一些相关的东西。<br>而不是去直面那个问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="一定要在搜索列表页面去筛选！包括看那些小的字。">一定要在搜索列表页面去筛选！包括看那些小的字。</h2><p>在网页列表里去筛选比进入网页内容然后发现他不是这个东西花的时间要少得多。<br>比如需要搜索windows下管理多个git ssh的问题，那么]]>
    </summary>
    
      <category term="thoughts" scheme="http://yoursite.com/tags/thoughts/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Android中使用unittest]]></title>
    <link href="http://yoursite.com/2015/04/30/Android%E4%B8%AD%E4%BD%BF%E7%94%A8UnitTest/"/>
    <id>http://yoursite.com/2015/04/30/Android中使用UnitTest/</id>
    <published>2015-04-30T02:42:24.000Z</published>
    <updated>2015-10-03T04:39:42.467Z</updated>
    <content type="html"><![CDATA[<p>在Android中使用unittest，不用再运行整个工程，只是测试某一些类是否正确运行。</p>
<hr>
<h2 id="步骤：">步骤：</h2><ol>
<li>设置Android studio，</li>
</ol>
<blockquote>
<p>Enable the unit testing feature in Settings &gt; Gradle &gt; Experimental.<br><img src="http://7xiu5y.com1.z0.glb.clouddn.com/blog_setting.png" alt="">    </p>
</blockquote>
<hr>
<ol>
<li>在Android studio左下角，有一个Build Variantes, 最上方选择Unit Tests.</li>
</ol>
<p><img src="http://7xiu5y.com1.z0.glb.clouddn.com/blog_build.png" alt=""><br>选择Unit Tests<br><img src="http://7xiu5y.com1.z0.glb.clouddn.com/blog_choose_artifact.png" alt="">    </p>
<hr>
<ol>
<li>愉快的写test就可以了   </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android中使用unittest，不用再运行整个工程，只是测试某一些类是否正确运行。</p>
<hr>
<h2 id="步骤：">步骤：</h2><ol>
<li>设置Android studio，</li>
</ol>
<blockquote>
<p>Enable ]]>
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hashmap的几个点]]></title>
    <link href="http://yoursite.com/2014/09/18/hashmap%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9/"/>
    <id>http://yoursite.com/2014/09/18/hashmap的几个点/</id>
    <published>2014-09-18T15:54:58.000Z</published>
    <updated>2015-10-03T07:42:20.295Z</updated>
    <content type="html"><![CDATA[<h2 id="总结：">总结：</h2><ul>
<li><p>解决碰撞是使用拉链法</p>
</li>
<li><p>为什么数组大小最好是2的整数次方，因为hashmap的hash函数并不是对数组大小取余，因为取余比较耗时，而是使用数组大小减1和hash值做与运算，如果数组大小不是2的整数次方，那么数组大小减1的二进制的最后一位就是0了，和key的hash值取与运算最后一位一直是0，所以有很大的空间浪费。</p>
</li>
<li><p>由于hashmap扩容需要重新计算所有元素的位置所以非常耗时，所以我们在知道hashmap大小的时候可以指定其大小，但是由于factory的存在，我们虽然知道指定2的整数次方，factory *  设定的数组大小 = 需要的数组大小，比如我们需要1000，不是设置为1024就好了，由于factory = 0.75，所以我们需要把数组大小设为 1000 / 0.75 然后再是2的整数次方，就是2048</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="总结：">总结：</h2><ul>
<li><p>解决碰撞是使用拉链法</p>
</li>
<li><p>为什么数组大小最好是2的整数次方，因为hashmap的hash函数并不是对数组大小取余，因为取余比较耗时，而是使用数组大小减1和hash值做与运算，如果数组大]]>
    </summary>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Activity的几种启动方式]]></title>
    <link href="http://yoursite.com/2014/09/18/Activity%E7%9A%84%E5%87%A0%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2014/09/18/Activity的几种启动方式/</id>
    <published>2014-09-18T15:46:13.000Z</published>
    <updated>2015-10-03T07:48:01.066Z</updated>
    <content type="html"><![CDATA[<h2 id="总结">总结</h2><hr>
<h3 id="standard：">standard：</h3><p>如果需要启动一个Activity，则会重新生成一个activity实例</p>
<h3 id="sigleTop:">sigleTop:</h3><p>如果需要启动的Activity刚刚好在栈顶，则不会再去创建Activity的实例,否则，创建Activity实例</p>
<h3 id="sigleTask">sigleTask</h3><p>如果在同一个应用中启动Activity，如果栈中没有，则创建新实例；如果有则直接杀死之上的所有activity使需要启动的activity成为栈顶<br>如果是在别的应用中启动该activity则会重新创建一个栈</p>
<h3 id="sigleInstance:">sigleInstance:</h3><p>只有一个实例并且单独运行在一个task中，这个task只有这个实例，不允许有别的activity存在。</p>
<h2 id="参考资料：">参考资料：</h2><hr>
<p><a href="http://blog.csdn.net/shinay/article/details/7898492" target="_blank" rel="external">http://blog.csdn.net/shinay/article/details/7898492</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="总结">总结</h2><hr>
<h3 id="standard：">standard：</h3><p>如果需要启动一个Activity，则会重新生成一个activity实例</p>
<h3 id="sigleTop:">sigleTop:</h3><p>如果需要]]>
    </summary>
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[行为型模式]]></title>
    <link href="http://yoursite.com/2014/03/20/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2014/03/20/行为型模式/</id>
    <published>2014-03-20T04:44:43.000Z</published>
    <updated>2015-10-03T04:43:41.010Z</updated>
    <content type="html"><![CDATA[<h2 id="策略模式（Strategy_Pattern)">策略模式（Strategy Pattern)</h2><ol>
<li><code>实现原理</code>：其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替</li>
<li><code>优点</code>：将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。<br><img src="/imgs/clms.png" alt=""></li>
</ol>
<hr>
<h2 id="迭代器模式（Iterator_Pattern)">迭代器模式（Iterator Pattern)</h2><ol>
<li><code>实现原理</code>：提供一种方法访问一个容器（container）对象中的各个元素，而又不暴露该对象的内部细节。</li>
<li><code>优点</code>：它可以让使用者透过特定的接口巡访容器中的每一个元素而不用了解底层的实现。<br><img src="/imgs/ddqms.png" alt=""></li>
</ol>
<hr>
<h2 id="模板方法模式（Template_Method_Pattern)">模板方法模式（Template Method Pattern)</h2><ol>
<li><code>实现原理</code>：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。这里的算法的结构，可以理解为你根据需求设计出来的业务流程。特定的步骤就是指那些可能在内容上存在变数的环节。</li>
<li><code>优点</code>：模板方法模式也是为了巧妙解决变化对系统带来的影响而设计的。使用模板方法使系统扩展性增强，最小化了变化对系统的影响。<br><img src="/imgs/mbffms.jpg" alt=""></li>
</ol>
<hr>
<h2 id="中介者模式（Mediator_Pattern)">中介者模式（Mediator Pattern)</h2><ol>
<li><code>实现原理</code>：用一个中介者对象来封装一系列的对象交互。中介者使各对象不需要显式的相互引用，从而使其耦合松散，而且可以独立的改变他们之间的交互。</li>
<li><code>优点</code>：它将各Colleague解耦。Mediator有利于各Colleague间的松耦合，你可以独立的改变和复用各Colleague类和Mediator类。 它简化了对象协议用Mediator和各Colleague间的一对多的交互来代替多对多的交互。一对多的关系更易于理解、维护和扩展。<br><img src="/imgs/zjzms.png" alt=""></li>
</ol>
<hr>
<h2 id="访问者模式（Visitor_Pattern)">访问者模式（Visitor Pattern)</h2><ol>
<li><code>实现原理</code>：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。（gof）<br>每一个元素实现visitable接口的accept方法接受一个visitor的实例对象，并且使用这个实例对象的visit方法来把自己的引用传递过去，<br><img src="/imgs/fwz1.png" alt=""><br>而真正调用时在concreteVisitor里面<br><img src="/imgs/fwz2.png" alt=""></li>
<li><code>优点</code>：<br><img src="/imgs/fwzms.png" alt="类图"></li>
</ol>
<hr>
<h2 id="职责链模式（Chain_of_Responsibility)">职责链模式（Chain of Responsibility)</h2><ol>
<li><code>实现原理</code>：通过给一个以上对象处理请求的机会来避免请求的发送者和接收者的耦合。链接接收对象并在链中传递请求直到有对象处理它。<br><img src="/imgs/zzlms.png" alt=""><br>我的理解：在每一个concreteHandler里面加入另外一个concreteHandler的对象的引用，从而实现处理的传递。</li>
<li><code>优点</code>：避免请求的发送者和接收者之间的耦合关系。</li>
</ol>
<hr>
<h2 id="状态模式（State_Pattern)">状态模式（State Pattern)</h2><ol>
<li><code>实现原理</code>：状态模式的意图是，允许一个对象在其内部状改变时改变它的行为。看起来就像是改变了它的类一样<br><img src="/imgs/ztms.png" alt=""><br>个人理解：这个跟职责链模式有很大的相似之处，职责链模式是他的处理的对象是排成一个链子，并且对象必须要把这个链子走完；但是状态模式的下一个引用就可能没有排成一个链子状，而且很多时候也不需要走完所有的状态，他指示把if else变成类之间的转换。</li>
<li><code>优点</code>：主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同的一系列类当中，可以把复杂的逻辑判断简单化。</li>
</ol>
<hr>
<h2 id="解释器模式（Interpreter_Pattern)">解释器模式（Interpreter Pattern)</h2><ol>
<li><code>实现原理</code>：定义语言的文法，并且建立一个解释器来解释该语言中的句子。它属于类的行为模式。这里的语言意思是使用规定格式和语法的代码。<br><img src="/imgs/jsqms.png" alt=""><ul>
<li>抽象表达式角色(AbstractExpression): 声明一个抽象的解释操作,这个接口为所有具体表达式角色都要实现的.</li>
<li>终结符表达式角色(TerminalExpression): 实现与文法中的元素相关联的解释操作,通常一个解释器模式中只有一个终结符表达式,但有多个实例对应不同的终结符.<br>终结符就是语言中用到的基本元素,一般不能再被分解,如: x -&gt; xa, 这里a是终结符，因为没有别的规则可以把a变成别的符号，不过x可以变成别的符号，所以x是非终结符.</li>
<li>非终结符表达式角色(NonterminalExpression): 文法中的每条规则对应于一个非终结表达式, 非终结表达式根据逻辑的复杂程度而增加,原则上每个文法规则都对应一个非终结符表达式.</li>
<li>环境角色(Context): 包含解释器之外的一些全局信息.</li>
</ul>
</li>
<li><code>应用环境</code>：<br>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。而且当文法简单、效率不是关键问题的时候效果最好。</li>
</ol>
<hr>
<h2 id="观察者模式（Observer_Pattern）">观察者模式（Observer Pattern）</h2><ol>
<li><code>实现原理</code>：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。也可以只通知部分。（gof）<br><img src="/imgs/gczms.png" alt=""><ul>
<li><code>抽象主题(Subject)角色</code>：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色.</li>
<li><code>具体主题(ConcreteSubject)角色</code>：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色.</li>
<li><code>抽象观察者(Observer)角色</code>：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口.</li>
<li><code>具体观察者(ConcreteObserver)角色</code>：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用.<br>在观察者模式中，又分为<code>推模型</code>和<code>拉模型</code>两种方式。</li>
<li>推模型:主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据.</li>
<li>拉模型:主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</li>
</ul>
</li>
<li><code>优点</code>：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</li>
</ol>
<hr>
<h2 id="命令模式（Command_Pattern)">命令模式（Command Pattern)</h2><ol>
<li><code>实现原理</code>：<br><img src="/imgs/mlms.png" alt=""><br>命令模式涉及到五个角色，它们分别是：<ul>
<li>客户端(Client)角色：创建一个具体命令(ConcreteCommand)对象并确定其接收者。</li>
<li>命令(Command)角色：声明了一个给所有具体命令类的抽象接口。</li>
<li>具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。</li>
<li>请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。</li>
<li>接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</li>
</ul>
</li>
<li><code>优点</code>：用于“行为请求者”与“行为实现者”解耦，可实现二者之间的松耦合，以便适应变化。分离变化与不变的因素。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="策略模式（Strategy_Pattern)">策略模式（Strategy Pattern)</h2><ol>
<li><code>实现原理</code>：其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替</li>
<li>]]>
    </summary>
    
      <category term="design pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[结构型模式]]></title>
    <link href="http://yoursite.com/2014/03/20/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2014/03/20/结构型模式/</id>
    <published>2014-03-20T03:44:42.000Z</published>
    <updated>2015-10-03T04:43:34.881Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="适配器模式（Adapter_Pattern)：">适配器模式（Adapter Pattern)：</h2><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。    </p>
<p>适配器模式有<code>类适配器</code>和<code>对象适配器</code>两种不同的类型：    </p>
<ul>
<li><p>类适配器：通过继承的方式来调用已有的接口来实现转换接口。<br><img src="/imgs/lspq.png" alt=""></p>
</li>
<li><p>对象适配器：通过对象引用的方式来调用已有的接口来实现接口的转换<br><img src="/imgs/dxspq.png" alt=""></p>
</li>
</ul>
<hr>
<h2 id="门面模式（Facade_Pattern)：">门面模式（Facade Pattern)：</h2><ol>
<li><code>实现原理：</code>它为子系统中的一组接口提供一个统一的高层接口，使得子系统更容易使用。也就是将众多的子接口或者子模    块包装一下，让客户更方便地调用。</li>
<li><p><code>优点：</code></p>
<ul>
<li>松散耦合：门面模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。</li>
<li>简单易用：门面模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟门面类交互就可以了.</li>
<li><p>更好的划分访问层次：通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到门面中，这样既方便客户端使用，也很好地隐藏了内部的细节。<br><img src="/imgs/mmms.png" alt=""></p>
</li>
<li><p>Facade:这个外观类为子系统中Packages 1、2、3提供一个共同的对外接口</p>
</li>
<li>Clients:客户对象通过一个外观接口读写子系统中各接口的数据资源。</li>
<li>Packages:客户可以通过外观接口读取的内部库。</li>
</ul>
</li>
</ol>
<p>描述门面模式的例子：<br><img src="/imgs/mmmslz.png" alt=""></p>
<hr>
<h2 id="代理模式（Proxy_pattern)：">代理模式（Proxy pattern)：</h2><ol>
<li><code>实现原理：</code>为其他对象提供一种代理以控制对这个对象的访问。</li>
<li><code>优点：</code>可以在实际调用的对象和客户端之间添加一些额外的操作。</li>
</ol>
<p>分为<code>静态代理</code>和<code>动态代理</code>：</p>
<ul>
<li>静态代理：<blockquote>
<p><img src="/imgs/jtdl.png" alt=""></p>
</blockquote>
</li>
<li>动态代理：</li>
</ul>
<hr>
<h2 id="合成模式（Composite_Pattern)：">合成模式（Composite Pattern)：</h2><ol>
<li><code>实现原理：</code>合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待。</li>
<li><code>优点：</code>合成模式使得客户端把一个个单独的成分对象和由它们复合而成的合成对象同等看待。<br><img src="/imgs/hcms.png" alt=""></li>
</ol>
<hr>
<h2 id="享元模式（Flyweight_Pattern)：">享元模式（Flyweight Pattern)：</h2><ol>
<li><code>实现原理</code>：<br><img src="/imgs/xyms.png" alt=""></li>
<li><code>优点</code>：享元模式以共享的方式高效地支持大量的细粒度对象。它适合用于当大量物件只是重复因而导致无法令人接受的使用大量内存。</li>
</ol>
<hr>
<h2 id="装饰着模式（Decorator_Pattern)：">装饰着模式（Decorator Pattern)：</h2><ol>
<li><code>实现原理</code>：是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。</li>
<li><code>优点</code>：就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。<br><img src="/imgs/zsz.jpg" alt=""></li>
</ol>
<hr>
<p>7.桥模式（Bridge Pattern)：</p>
<ol>
<li><code>实现原理</code>：桥模式就是把抽象部分和它的实现部分分离开来，让两者可独立变化。(或者说：把事物对象和其具体行为、具体特征分离开来，使它们可以各自独立的变化。事物对象仅是一个抽象的概念。如“圆形”、“三角形”归于抽象的“形状”之下，而“画圆”、“画三角”归于实现行为的“画图”类之下，然后由“形状”调用“画图”)<br><img src="/imgs/qjms.jpg" alt=""><br>组成：<ul>
<li>抽象化(Abstraction)角色：抽象化给出的定义，并保存一个对实现化对象的引用。</li>
<li>修正抽象化(Refined Abstraction)角色：扩展抽象化角色，改变和修正父类对抽象化的定义。</li>
<li>实现化(Implementor)角色：这个角色给出实现化角色的接口，但不给出具体的实现。必须指出的是，这个接口不一定和抽象化角色的接口定义相同，实际上，这两个接口可以非常不一样。</li>
<li>具体实现化(Concrete Implementor)角色：这个角色给出实现接口的具体实现。</li>
</ul>
</li>
<li>优点：桥模式就是把抽象部分和它的实现部分分离开来，让两者可独立变化。分离就把实现部分从它要实现的抽象部分独立出来，自我封装成对象。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="适配器模式（Adapter_Pattern)：">适配器模式（Adapter Pattern)：</h2><p>将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。    </p>
<p]]>
    </summary>
    
      <category term="design pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[建造型设计模式]]></title>
    <link href="http://yoursite.com/2014/03/20/%E5%BB%BA%E9%80%A0%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2014/03/20/建造型设计模式/</id>
    <published>2014-03-20T02:44:41.000Z</published>
    <updated>2015-10-03T04:43:44.963Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="简单工厂：">简单工厂：</h2><p>它的实质是由一个工厂类根据传入的参 数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。将所有的类的创建放到一个类中。</p>
<hr>
<h2 id="工厂方法：">工厂方法：</h2><p>工厂方法模式是为了克服简单工厂模式的缺点（主要是为了满足OCP）而设计出来的。简单工厂模式的工厂类随着产品类的增加需要增加很多方法 （或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。工厂方法模式完全满足OCP，即它有非常良好的扩展性。<br><img src="/imgs/dsign_pattern1_1.png" alt=""></p>
<hr>
<h2 id="抽象工厂：">抽象工厂：</h2><p>克服工厂方法增长速度太快的弊端。将同类产品抽象成一个工厂，从而减少工厂类的数量。<br><img src="/imgs/cxgc.jpg" alt=""></p>
<hr>
<h2 id="单例模式：">单例模式：</h2><p>可以使创建的对象只有一个，从而实现线程安全或保证数据单一。但是实现线程安全的单例需要在创建对象的时候加上synchronized代码块。</p>
<hr>
<h2 id="原型模式：">原型模式：</h2><p>原型模式被用在频繁调用且极其相似的对象上。原型模式会克隆对象并设置改变后的属性。原型模式消耗的资源较少。<br><img src="/imgs/yxms.png" alt=""></p>
<hr>
<h2 id="创建者模式：">创建者模式：</h2><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。为何使用建造者模式是为了将构建复杂对象的过程和它的部件解耦。注意：是解耦过程和部件。<br>因为一个复杂的对象，不但有很多大量组成部分，如汽车，有很多部件：车轮、方向盘、发动机，还有各种小零件等等，部件很多，但远不止这些，如何将这些部件装配成一辆汽车，这个装配过程也很复杂(需要很好的组装技术)，Builder模式就是为了将部件和组装过程分开。<br><img src="/imgs/cjz.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="简单工厂：">简单工厂：</h2><p>它的实质是由一个工厂类根据传入的参 数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。将所有的类的创建放到一个类中。</p>
<hr>
<h2 id="工厂方法：">工厂方法：</h2><p]]>
    </summary>
    
      <category term="design pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[design_pattern]]></title>
    <link href="http://yoursite.com/2014/03/20/design-pattern/"/>
    <id>http://yoursite.com/2014/03/20/design-pattern/</id>
    <published>2014-03-20T01:44:40.000Z</published>
    <updated>2015-10-03T04:43:44.963Z</updated>
    <content type="html"><![CDATA[<h1 id="设计模式的总结">设计模式的总结</h1><hr>
<h2 id="设计模式的分类：">设计模式的分类：</h2><ul>
<li><h2 id="建造型设计模式(Creational_Patterns)"><a href="../建造型设计模式">建造型设计模式(Creational Patterns)</a></h2><ol>
<li>工厂方法模式(Factory Method)</li>
<li>抽象工厂模式(Abstract Factory)</li>
<li>单例模式(Singleton)</li>
<li>原型模式(prototype)</li>
<li>建造者模式(Builder)</li>
</ol>
</li>
</ul>
<ul>
<li><h2 id="结构型模式(Structural_Patterns)"><a href="../结构型模式">结构型模式(Structural Patterns)</a></h2><ol>
<li>适配器模式（Adapter Pattern)</li>
<li>门面模式（Facade Pattern)</li>
<li>代理模式（Proxy pattern)</li>
<li>合成模式（Composite Pattern)</li>
<li>享元模式（Flyweight Pattern)</li>
<li>装饰着模式（Decorator Pattern)</li>
<li>桥模式（Bridge Pattern)</li>
</ol>
</li>
</ul>
<ul>
<li><h2 id="行为型模式（Behavioral_Patterns)"><a href="../行为型模式">行为型模式（Behavioral Patterns)</a></h2><ol>
<li>策略模式（Strategy Pattern)</li>
<li>迭代器模式（Iterator Pattern)</li>
<li>模板方法模式（Template Method Pattern)</li>
<li>中介者模式（Mediator Pattern)</li>
<li>访问者模式（Visitor Pattern)</li>
<li>职责链模式（Chain of Responsibility)</li>
<li>状态模式（State Pattern)</li>
<li>解释器模式（Interpreter Pattern)</li>
<li>观察者模式（Observer Pattern)</li>
<li>命令模式（Command Pattern)</li>
<li>备忘录模式（Memento Pattern)</li>
</ol>
</li>
</ul>
<p><img src="/imgs/design_pattern1.jpg" alt="design pattern "></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="设计模式的总结">设计模式的总结</h1><hr>
<h2 id="设计模式的分类：">设计模式的分类：</h2><ul>
<li><h2 id="建造型设计模式(Creational_Patterns)"><a href="../建造型设计模式">建造型设计模式]]>
    </summary>
    
      <category term="design pattern" scheme="http://yoursite.com/tags/design-pattern/"/>
    
  </entry>
  
</feed>